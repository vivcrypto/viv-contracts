Auction contracts apply to auctions in cryptocurrency to make sure its fairness and impartiality.

### Transaction scenarios

#### Auction


1) The initiator calls the “publish” function of the contract to launch an auction.
2) The bidders call the “bidding” function of the contract to place bids.
3) The initiator calls the “endAuction” function to end the auction. Except for the highest bidder, the funds of the rest will be refunded back via the coming route.
4) The initiator ships the goods/services to the highest bidder.
5) The highest bidder confirms receipt (agrees to pay to the initiator; signs to the transaction).
6) The initiator calls the “withdraw” function of the contract to withdraw the payment.

Please note:

1) The bidders, except the highest bidder, can withdraw from the auction while it is still going on. By calling the “refund” function of the contract, the payment will be refunded via the coming route.
2) If the highest bidder never confirms receipt of goods/services, after a certain period of time, the platform will automatically confirm the receipt and the initiator still can withdraw the payment.

### On contracts

Contracts are generated by the platform. One contract can be used by multiple parties. Token types supported are ETH only (ERC20 tokens need to be authorized so there exists uncertainty; therefore not supported).

#### Launch auction

Parameters

- address guarantee: the guarantor (in this case, the platform). When the highest bidder does not sign to confirm receipt within a certain period of time, the guarantor signs and the initiator can withdraw the payment.
- bytes calldata signHex: the character string for signature; one signs to the string
- uint256 endTime: the closing time of bidding. This time cannot be less than the current time, and is accurate to seconds.
- uint256 startPrice: start price for bidding
- uint256 range: the added-on amount for every bidding. The bidding price must equal starting bidding price plus multipliers of this fixed added-on amount (bidding price = starting price + n*mark-up)
- uint256 feeRate: platform service fee rate (please note that the number here is 1/10,000; for example, 2000 refers to 20%, and 500 refers to 5%)

#### bidding

Parameters:

- uint256 id: transaction ID, which will be sent back when the “bidding” function is called.

Please note:

> The amount of the bid is “msg.value.” This amount must be higher than the current highest bid, also after the starting price is deducted from it, it should be a multiplier of the fixed added-on amount (mark-up). 

#### endAuction
Parameters

- uint256 id: transaction ID, which will be sent back when the “bidding” function is called.

Please note:
> - The function must be called before the auction ends, or an error will be reported.
> - Except for the highest bidder, the payments of the rest bidders will be sent back via the coming route.

#### Exit auction

Parameters

- uint256 id: transaction ID, which will be sent back when the “bidding” function is called.

Please note:
> One who calls this function will get refunded via the coming route, but he cannot be the highest bidder.

#### withdraw
Parameters

- uint256 id: transaction ID, which will be sent back when the “bidding” function is called.
- bytes calldata sign1: the highest bidder or the platform signs; signature rules in “signature rules.”
- bytes calldata sign2: platform signs, only when the initiator uses a coupon; signature rules in “signature rules.”
- uint256 couponRate: coupon rate (please note that the number here is 1/10,000; for example, 2000 refers to 20%, and 500 refers to 5%)
- bytes memory couponId: coupon ID


Please note: 

> - Only the initiator can call the contract.
> during withdrawal, the platform will charge a service fee; with a coupon part or all of the fee can be waived.
> - service fee = highest bid * platform service fee rate
> - discounted service fee = service fee * coupon rate
> - final service fee = service fee - discount

#### Signature rules:
1) “sign1” is generated based on the following rules:
>    - calculate the hash of “signHex,” and then sign with the highest bidder’s or the platform’s private key to this hash.
2) “sign2” is generated based on the following rules:
>    - calculate the hash values of coupon rate, coupon ID and transaction ID, and use the platform’s private key to sign toward these hash.

#### Signature example

Take the calculation of signedValue1 (with arbitration) as an example:
- transaction amount: 10000000 wei
- arbitration fee: 2000000 wei
- transaction ID: 457542584823209984

The js code for hash calculation and signature are the following:
> npm install web3
```
let ethUtil = require("ethereumjs-util");
const Web3 = require('web3')
const web3 = new Web3()

let tid = "457542584823209984";
let privateKey = "0xf95816c196aec67bdae2f72005d4b11203162c72ed4e3833958e052df8a32edd";

/**
* calculate hash
 * @param {*} types (format as)：['uint256', 'uint256', 'uint256', 'bytes']
 * @param {*} values  (format as)：[200, 500, 100, "0x343838363937323533343434323539383430"]
 * @returns 
 */
function getHash(types, values) {
  const data = ethUtil.toBuffer(web3.eth.abi.encodeParameters(types, values));
  const buf = Buffer.concat([
    Buffer.from(
    "\u0019Ethereum Signed Message:\n" + data.length.toString(),
    "utf8"
    ),
    data
  ]);
  const hash = ethUtil.keccak256(buf);
  return ethUtil.bufferToHex(hash);
}

const data = ethUtil.bufferToHex(ethUtil.toBuffer(Buffer.from(tid, "utf8")));
var msgHash = ethUtil.toBuffer(getHash(['uint256', 'uint256', 'bytes'], [web3.utils.toWei('10000000', 'gwei'), web3.utils.toWei('2000000', 'gwei'), data]));

const rsv = ethUtil.ecsign(msgHash, ethUtil.toBuffer(privateKey));
console.log("hash: 0x" + msgHash.toString('hex'));
console.log("sign: 0x" + rsv.r.toString('hex') + rsv.s.toString('hex') + rsv.v.toString(16));
```
