Crowdfunding applies to gathering of donations or funds, scenarios like charity and non-profit projects.

### Transaction Scenarios

#### Crowdfunding

1) The initiator calls the “createVivCrowdfunding” function of the factory contract to create a crowdfunding contract. It costs much less gas fees compared to creating a contract directly.
2) The participants directly transfer to the contract.
3) The initiator calls the “withdraw” function of the crowdfunding contract to withdraw funds. Before the initiator withdraws, he and the platform need to sign to the transaction volume, service fees and transaction ID. When he withdraws, confirmation signatures are needed.

### On contracts

Factory contracts are generated by the platform. The initiator creates a crowdfunding contract through the factory contract. One factory contract can be repeatedly used. Token types supported are ETH and ERC20 tokens.

#### createVivCrowfunding
Parameters

- address libraryAddress: the address of the crowdfunding contract. The factory recreates the same new contract through this address.
- address platform: the address of the platform’s wallet, which is used for confirmation signature and collection of service fees.
- uint256 feeRate: platform service fee rate (please note that the number here is 1/10,000; for example, 2000 refers to 20%, and 500 refers to 5%)
- address token: crowdfunding token type. If it is 0x0000000000000000000000000000000000000000, it refers to Ethereum, the rest refers to the corresponding ERC20 token types.

> Calling this function will create a new contract. The address of the new contract will be sent back in the form of sending back parameters; also it is searchable in blockchain explorer by the hash value of the transaction.

#### withdraw
Parameters

- bytes memory signedValue1: the initiator or the platform’s signature; signature rules in “signature rules.”
- bytes memory signedValue2: the initiator or the platform’s signature; signature rules in “signature rules.”
-bytes memory signedValue3: platform signs, only when buyer or seller uses a coupon; signature rules in “signature rules.”
- uint256 value: withdrawal amount
- uint256 couponRate: coupon rate (please note that the number here is 1/10,000; for example, 2000 refers to 20%, and 500 refers to 5%)
- bytes memory tid: transaction ID
- bytes memory couponId: coupon ID

> during withdrawal, the platform will charge a service fee; with a coupon part or all of the fee can be waived.
> - service fee = withdrawal amount * platform service fee rate
> - discounted service fee = service fee * coupon rate
> - final service fee = service fee - discount

#### signature rules:
1) signedValue1 or signedValue2 are generated based on the following rules:
   - When without arbitration, calculate the hash of the transaction ID, and use the buyer’s, seller’s and the arbitrator’s private keys to sign toward this hash.
   - When with arbitration, calculate the hash values of the transaction amount, arbitration fee and the transaction ID, and use the buyer’s, seller’s and the arbitrator’s private keys to sign toward these hash values.
2) signedValue3 is generated based on the following rules:
   - calculate the hash values of coupon rate, coupon ID and transaction ID, and use the platform’s private key to sign toward these hash.

#### signature example

Take the calculation of signedValue1 (with arbitration) as an example:
- transaction amount: 10000000 wei
- arbitration fee: 2000000 wei
- transaction ID: 457542584823209984

The js code for hash calculation and signature are the following:
> npm install web3
```
let ethUtil = require("ethereumjs-util");
const Web3 = require('web3')
const web3 = new Web3()

let tid = "457542584823209984";
let privateKey = "0xf95816c196aec67bdae2f72005d4b11203162c72ed4e3833958e052df8a32edd";

/**
* calculate hash
 * @param {*} types (format as)：['uint256', 'uint256', 'uint256', 'bytes']
 * @param {*} values  (format as)：[200, 500, 100, "0x343838363937323533343434323539383430"]
 * @returns 
 */
function getHash(types, values) {
  const data = ethUtil.toBuffer(web3.eth.abi.encodeParameters(types, values));
  const buf = Buffer.concat([
    Buffer.from(
    "\u0019Ethereum Signed Message:\n" + data.length.toString(),
    "utf8"
    ),
    data
  ]);
  const hash = ethUtil.keccak256(buf);
  return ethUtil.bufferToHex(hash);
}

const data = ethUtil.bufferToHex(ethUtil.toBuffer(Buffer.from(tid, "utf8")));
var msgHash = ethUtil.toBuffer(getHash(['uint256', 'uint256', 'bytes'], [web3.utils.toWei('10000000', 'gwei'), web3.utils.toWei('2000000', 'gwei'), data]));

const rsv = ethUtil.ecsign(msgHash, ethUtil.toBuffer(privateKey));
console.log("hash: 0x" + msgHash.toString('hex'));
console.log("sign: 0x" + rsv.r.toString('hex') + rsv.s.toString('hex') + rsv.v.toString(16));
