DAO contracts apply to the situation of gathering funds for a certain project. As a reward, the DAO contract will issue a certain amount of ERC20 tokens to the participants. These tokens can be traded after the participants have received them.

### Transaction Scenarios

#### DAO transaction process

1) The initiator calls the “constructor” function to create a contract and get the contract address of DAO.
2) The initiator calls the DAO TOKEN “constructor” function to create the DAO TOKEN contract and get the DAO TOKEN contract address. Note that creating the DAO TOKEN contract, the DAO contract address needs to be imported in order to make the DAO contract the owner of DAO TOKEN.
3) The initiator publishes the related information of the DAO project, including the project introduction, DAO contract address, etc. 
4) The participant calls the “purchase” function of the DAO contract to pay. This function supports payments in ETH or ERC20 tokens to the contract, and it realizes the DAO TOKEN minting and transferring of tokens to the participants.
5) When the initiator has gathered a certain amount of ETH or ERC20 tokens, he can withdraw. When he withdraws, he can decide the number of tokens and DAO tokens he wants to withdraw.

### On contracts

The contract is generated by an individual. The token types supported are ETH and ERC20 tokens.

#### Create constructor contract

Parameters

- address _payToken: The token types gathered. If it is 0x0000000000000000000000000000000000000000, it refers to Ethereum, the rest refers to the corresponding ERC20 token types.
- uint256 _exchange: the exchange rate. For example, 1 ETH can exchange 100 DAO TOKENs.
- uint256 _target: the target amount for crowdfunding; once exceeded, no more funds will be gathered.
- uint256 _reserved: the reserve rate of DAO TOKEN for the initiator (please note that the number here is 1/10,000; for example, 2000 refers to 20%, and 500 refers to 5%); the rest will be given to the participants.
- uint256 _discount: the deflation rate (please note that the number here is 1/10,000; for example, 2000 refers to 20%, and 500 refers to 5%); the initiator can limit the trading volume of DAO TOKEN via the deflation rate so that the value of DAO TOKEN will not drop.
- address _platform: the address of the platform’s wallet, which is used for collection of service fees.
- uint256 feeRate: platform service fee rate (please note that the number here is 1/10,000; for example, 2000 refers to 20%, and 500 refers to 5%)

#### purchase
This function pays to the contract. And it calls a DAO TOKEN contract to mint tokens and send DAO TOKENs to the participants. The number of tokens sent out is as following:

> - DAO TOKEN number to be minted = transaction amount * exchange rate * (1- deflation rate)
> - DAO TOKEN number the participants can get = DAO TOKEN number to be minted * (1-reserve rate for the initiator)

Parameters

- uint256 value: amount paid
- address _daoToken: DAO TOKEN contract address
- bytes calldata tid: Transaction ID

Please note:

1) If paying through Ethereum, then one should make sure the wallet balance should not be less than the transaction amount. Choosing this payment method means that at the same time Ethereum will be transferred into the contract. In this case, “msg.value” should equal “value.”
2) If paying through ERC20 tokens, then one should authorize the contract in advance, and the authorized amount should be no less than the transaction amount. When paying, the contract will call ERC20’s “transferFrom” to deduct the payment amount.

#### withdraw
The initiator can use this function to withdraw the gathered tokens and the reserved DAO TOKENs.

Parameters

- uint256 payTokenValue: the number of gathered tokens to be withdrawn
- uint256 daoTokenValue: the number of DAO TOKENs to be withdrawn
- bytes memory signedValue: platform signs, only when the initiator uses a coupon; signature rules in “Signature Rules.”
- uint256 couponRate: coupon rate (please note that the number here is 1/10,000; for example, 2000 refers to 20%, and 500 refers to 5%)
- bytes memory tid: transaction ID
- bytes memory couponId: coupon ID

> during withdrawal, the platform will charge a service fee; with a coupon part or all of the fee can be waived.
> - service fee = withdrawal amount * platform service fee rate
> - discounted service fee = service fee * coupon rate
> - final service fee = service fee - discount
> - Please note: The service fees are composed of two parts; one part is the gathered tokens, and the other is DAO TOKENs. The calculation formula is the same.

#### newRound
The initiator can call this function to launch a new round of crowdfunding, or to reset the target amount, the reserve rate and the deflation rate.

Parameters
- uint256 _target: the target amount of crowdfunding; once exceeded, no more funds will be gathered.
uint256 _reserved: the reserve rate of DAO TOKEN for the initiator (please note that the number here is 1/10,000; for example, 2000 refers to 20%, and 500 refers to 5%); the rest will be given to the participants.
- uint256 _discount: the deflation rate (please note that the number here is 1/10,000; for example, 2000 refers to 20%, and 500 refers to 5%); the initiator can limit the trading volume of DAO TOKEN via the deflation rate so that the value of DAO TOKEN will not drop.
> When using this function to set the target amount for the new round, the previous target will become invalid. The gathered tokens and the reserved DAO TOKENs from the previous round can still be withdrawn and will be added to the new round’s crowdfunding.

#### signature rules:
> signedValue is generated based on the following rules:
>    - calculate the hash values of coupon rate, coupon ID and transaction ID, and use the platform’s private key to sign toward these hash values.

#### signature example
Take the calculation of signedValue1 (with arbitration) as an example:
- transaction amount: 10000000 wei
- arbitration fee: 2000000 wei
- transaction ID: 457542584823209984

The js code for hash calculation and signature are the following:
> npm install web3
```
let ethUtil = require("ethereumjs-util");
const Web3 = require('web3')
const web3 = new Web3()

let tid = "457542584823209984";
let privateKey = "0xf95816c196aec67bdae2f72005d4b11203162c72ed4e3833958e052df8a32edd";

/**
* calculate hash
 * @param {*} types ：['uint256', 'uint256', 'uint256', 'bytes']
 * @param {*} values  ：[200, 500, 100, "0x343838363937323533343434323539383430"]
 * @returns 
 */
function getHash(types, values) {
  const data = ethUtil.toBuffer(web3.eth.abi.encodeParameters(types, values));
  const buf = Buffer.concat([
    Buffer.from(
    "\u0019Ethereum Signed Message:\n" + data.length.toString(),
    "utf8"
    ),
    data
  ]);
  const hash = ethUtil.keccak256(buf);
  return ethUtil.bufferToHex(hash);
}

const data = ethUtil.bufferToHex(ethUtil.toBuffer(Buffer.from(tid, "utf8")));
var msgHash = ethUtil.toBuffer(getHash(['uint256', 'uint256', 'bytes'], [web3.utils.toWei('10000000', 'gwei'), web3.utils.toWei('2000000', 'gwei'), data]));

const rsv = ethUtil.ecsign(msgHash, ethUtil.toBuffer(privateKey));
console.log("hash: 0x" + msgHash.toString('hex'));
console.log("sign: 0x" + rsv.r.toString('hex') + rsv.s.toString('hex') + rsv.v.toString(16));
```


### Look-up methods

#### All transactions
To look up for all the situations of the participants of the DAO contract, such as token types paid, amounts paid, amounts exchanged, wallet addresses, transaction IDs and round numbers.

#### All targets
To look up for the rounds the DAO contract has already launched, such as the gathered amounts for every round, amounts actually gathered, reserve rate and deflation rate.

#### The total amount of crowdfunding targets

#### The total amount of gathered amounts
