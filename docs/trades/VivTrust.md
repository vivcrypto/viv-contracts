The functions of a traditional trust fund include: avoiding taxes; having certain legal protection; avoiding court certification; protecting children’s assets after divorce. There are several types of trust funds based on the clients’ needs, such as revocable and irrevocable trusts, legacy trust, marriage trust and family trust.
VIV will do the revocable trust based on smart contracts first.

### Transaction scenarios

#### 1. Trust without revision later

1) The initiator creates the transaction.
2) The initiator pays (call the “purchase” function of the contract) to the contract.
3) The beneficiary withdraws from the contract (calls the “withdraw” function of the contract). The beneficiary can withdraw several times based on the predetermined schedule, or can accumulate the amounts several times and withdraw them once altogether.

Please note:
1) The amounts the beneficiary can withdraw are calculated based on the fund transferred to the contract, the unlocking dates, the interval days, the amounts for each unlock. The beneficiary can only withdraw the amount that has been unlocked.
2) If the beneficiary decides to accumulate the amounts of several rounds and take them out altogether at one point, it might be affected by the fact that the initiator may change the trust fund arrangements. Because if the arrangements are changed, the unlocking schedule will be rearranged as well.

#### 2. Cancel a trust fund

1) The initiator creates the transaction.
2) The initiator pays (call the “purchase” function of the contract) to the contract.
3) The initiator withdraws from the contract (calls the “withdraw” function of the contract). The withdrawal of the initiator is not time-sensitive, and he can withdraw all of the amount left in the contract.

#### 3. Revise a trust fund

1) The initiator creates the transaction.
2) The initiator pays (call the “purchase” function of the contract) to the contract.
3) The initiator calls the “setProject” function of the contract to reset the starting date of unlocking, the interval days, and the respective amount for each unlock/release.
4) The initiator withdraws from the contract (calls the “withdraw” function of the contract); the beneficiary can calculate the amounts he can withdraw based on the new rules.

### On contracts

Contracts are generated by the platform. One contract can support multiple transactions. Different transactions can be distinguished from their different transaction IDs. Token types supported are ETH and ERC20 tokens.

#### payment methods

Parameters

- address trustee: the wallet address of the beneficiary
- address platform: the wallet address of the platform, used to collect service fees
- uint256 startDate: the starting date of the unlocking of funds
- uint256 intervalDays: the interval days between two unlocking days
- uint256 intervalAmount: the amount being unlocked each time
- uint256 value: the amount paid by the initiator (the amount in the trust fund; can be paid in multiple times)
- bytes memory tid: Transaction ID
- address token: transaction token type. If it is 0x0000000000000000000000000000000000000000, it refers to Ethereum, the rest refers to the corresponding ERC20 token types.
- uint256 feeRate: platform service fee rate (please note that the number here is 1/10,000; for example, 2000 refers to 20%, and 500 refers to 5%)

Please note:

1) If paying through Ethereum, then one should make sure the wallet balance should not be less than the transaction amount. Choosing this payment method means that at the same time Ethereum will be transferred into the contract. In this case, msg.value should equal value.
2) If paying through ERC20 tokens, then one should authorize the contract in advance, and the authorized amount should be  no less than the transaction amount. When paying, the contract will call ERC20’s “transferFrom” function to deduct the payment amount.

#### withdrawal methods

Parameters

- bytes memory signedValue: platform signs, only when beneficiary or initiator uses a coupon; signature rules in “signature rules.”
- uint256 value: withdrawal amount, including service fee and arbitration fee
- uint256 couponRate: coupon rate (please note that the number here is 1/10,000; for example, 2000 refers to 20%, and 500 refers to 5%)
- bytes memory tid: transaction ID
- bytes memory couponId: coupon ID

> during withdrawal, the platform will charge a service fee; with a coupon part or all of the fee can be waived.
> - service fee = withdrawal amount * platform service fee rate
> - discounted service fee = service fee * coupon rate
> - final service fee = service fee - discount

#### Signature rules:
> “signedValue” is generated based on the following rules: 
>    - calculate the hash values of coupon rate, coupon ID and transaction ID, and use the platform’s private key to sign toward these hash values.

#### Signature example
Take the calculation of signedValue (when use a coupon) as an example:
- Coupon Rate: 2000
- Coupon ID: ：529547173390454784
- Transaction ID: 457542584823209984

The js code for hash calculation and signature are the following:
> npm install web3
```
let ethUtil = require("ethereumjs-util");
const Web3 = require('web3')
const web3 = new Web3()

let couponRate = 2000;
let couponId = "529547173390454784";
let tid = "457542584823209984";

let privateKey = "0xf95816c196aec67bdae2f72005d4b11203162c72ed4e3833958e052df8a32edd";

/**
* calculate hash
 * @param {*} types (format as)：['uint256', 'uint256', 'uint256', 'bytes']
 * @param {*} values  (format as)：[200, 500, 100, "0x343838363937323533343434323539383430"]
 * @returns 
 */
function getHash(types, values) {
  const data = ethUtil.toBuffer(web3.eth.abi.encodeParameters(types, values));
  const buf = Buffer.concat([
    Buffer.from(
    "\u0019Ethereum Signed Message:\n" + data.length.toString(),
    "utf8"
    ),
    data
  ]);
  const hash = ethUtil.keccak256(buf);
  return ethUtil.bufferToHex(hash);
}

const data1 = ethUtil.bufferToHex(ethUtil.toBuffer(Buffer.from(couponId, "utf8")));
const data2 = ethUtil.bufferToHex(ethUtil.toBuffer(Buffer.from(tid, "utf8")));
var msgHash = ethUtil.toBuffer(getHash(['uint256', 'bytes', 'bytes'], [couponRate, data1, data2]));

const rsv = ethUtil.ecsign(msgHash, ethUtil.toBuffer(privateKey));
console.log("hash: 0x" + msgHash.toString('hex'));
console.log("sign: 0x" + rsv.r.toString('hex') + rsv.s.toString('hex') + rsv.v.toString(16));
```
